package org.activityinfo.model.formTree;

import com.google.common.base.Function;
import com.google.common.base.Optional;
import com.google.common.collect.Iterables;
import org.activityinfo.model.form.FormClass;
import org.activityinfo.model.form.FormField;
import org.activityinfo.model.form.FormInstance;
import org.activityinfo.model.resource.ResourceId;
import org.activityinfo.model.type.*;
import org.activityinfo.model.type.primitive.TextType;
import org.activityinfo.promise.Maybe;

import java.util.ArrayList;
import java.util.Collections;
import java.util.List;

/**
 * Constructs a cascading set of LookupKeys that can be used
 * to find or label the value of a record field.
 */
public class LookupKeySet {

    private final FormTree tree;
    private final List<LookupKey> keys;
    private final FormField field;

    public LookupKeySet(FormTree tree, FormField field) {
        this.tree = tree;
        this.field = field;
        keys = findKeys(field);
    }

    private List<LookupKey> findKeys(FormField field) {
        assert field.getType() instanceof ReferenceType : field + " is not a reference field";

        ReferenceType referenceType = (ReferenceType) field.getType();
        ResourceId referencedFormId = Iterables.getOnlyElement(referenceType.getRange());
        FormClass referencedForm = tree.getFormClass(referencedFormId);

        return findKeys(referencedForm);
    }


    private List<LookupKey> findKeys(FormClass formSchema) {


        // If a serial number is present, ALWAYS use that for lookup
        Optional<FormField> serialNumber = firstFieldOfType(formSchema, SerialNumberType.TYPE_CLASS);
        if(serialNumber.isPresent()) {
            return Collections.singletonList(new LookupKey(formSchema, serialNumber.get()));
        }


        // Otherwise look for "parent" keys formed when
        // reference fields are marked as keys

        List<LookupKey> parentKeys = new ArrayList<>();
        for (FormField field : formSchema.getFields()) {
            if(field.isKey() && field.getType() instanceof ReferenceType) {
                parentKeys.addAll(findKeys(field));
            }
        }

        // Now find our leaf keys
        List<LookupKey> leafKeys = new ArrayList<>();

        // First try for explicitly defined keys
        for (FormField field : formSchema.getFields()) {
            if(field.isKey()) {
                LookupKey key = new LookupKey(formSchema, field, parentKeys);
                leafKeys.add(key);
                parentKeys.add(key);
            }
        }

        // If there are no explicitly defined keys, then use the first text field
        if(leafKeys.isEmpty()) {
            Optional<FormField> textField = firstFieldOfType(formSchema, TextType.TYPE_CLASS);
            if(textField.isPresent()) {
                LookupKey key = new LookupKey(formSchema, textField.get(), parentKeys);
                leafKeys.add(key);
                parentKeys.add(key);
            }
        }

        // Otherwise we have to use the autogenerated id :-(
        if(leafKeys.isEmpty()) {
            parentKeys.add(new LookupKey(formSchema, parentKeys));
        }

        return parentKeys;
    }

    private Optional<FormField> firstFieldOfType(FormClass formClass, FieldTypeClass typeClass) {
        for (FormField formField : formClass.getFields()) {
            if(formField.getType().getTypeClass().equals(typeClass)) {
                return Optional.of(formField);
            }
        }
        return Optional.absent();
    }

    public Maybe<String> label(RecordTree tree, RecordRef ref) {
        if(keys.size() == 1) {
            Maybe<FormInstance> record = tree.getRecord(ref);
            return record.transform(new Function<FormInstance, String>() {
                @Override
                public String apply(FormInstance record) {
                    return keys.get(0).label(record);
                }
            });
        } else {
            return Maybe.of("TODO");
        }
    }


    public List<LookupKey> getKeys() {
        return keys;
    }
}

