package org.activityinfo.model.formTree;

import com.google.common.base.Function;
import com.google.common.base.Optional;
import com.google.common.collect.Iterables;
import org.activityinfo.model.form.FormClass;
import org.activityinfo.model.form.FormField;
import org.activityinfo.model.form.FormInstance;
import org.activityinfo.model.resource.ResourceId;
import org.activityinfo.model.type.*;
import org.activityinfo.model.type.primitive.TextType;
import org.activityinfo.promise.Maybe;

import java.util.ArrayList;
import java.util.Collections;
import java.util.List;

/**
 * Constructs a cascading set of LookupKeys that can be used
 * to find or label the value of a record field.
 */
public class LookupKeySet {

    private final FormTree tree;
    private final List<LookupKey> keys;

    public LookupKeySet(FormTree tree, FormField field) {
        this.tree = tree;
        this.keys = findKeys(field);
    }

    public LookupKeySet(FormTree tree, ReferenceType referenceType) {
        this.tree = tree;
        this.keys = findKeys(referenceType);

    }

    private List<LookupKey> findKeys(FormField field) {
        assert field.getType() instanceof ReferenceType : field + " is not a reference field";

        ReferenceType referenceType = (ReferenceType) field.getType();
        return findKeys(referenceType);
    }

    private List<LookupKey> findKeys(ReferenceType referenceType) {
        ResourceId referencedFormId = Iterables.getOnlyElement(referenceType.getRange());
        FormClass referencedForm = tree.getFormClass(referencedFormId);

        return findKeys(referencedForm);
    }


    private List<LookupKey> findKeys(FormClass formSchema) {


        // If a serial number is present, ALWAYS use that for lookup
        Optional<FormField> serialNumber = firstFieldOfType(formSchema, SerialNumberType.TYPE_CLASS);
        if(serialNumber.isPresent()) {
            return Collections.singletonList(new LookupKey(formSchema.getLabel(), formSchema, serialNumber.get()));
        }

        if(!hasExplicitKeys(formSchema)) {
            return findImplicitKeys(formSchema);
        }

        // Otherwise look for "parent" keys formed when
        // reference fields are marked as keys

        List<LookupKey> keys = new ArrayList<>();
        for (FormField field : formSchema.getFields()) {
            if(field.isKey() && field.getType() instanceof ReferenceType) {
                keys.addAll(findKeys(field));
            }
        }

        // Now find our leaf keys
        List<FormField> leafKeyFields = findExplicitLeafKeys(formSchema);

        if(leafKeyFields.size() == 1) {
            keys.add(new LookupKey(formSchema.getLabel(), formSchema, leafKeyFields.get(0), keys));

        }  else if(leafKeyFields.size() > 1) {
            for (FormField leafKeyField : leafKeyFields) {
                keys.add(new LookupKey(formSchema.getLabel() + " " + leafKeyField.getLabel(), formSchema, leafKeyField, keys));
            }
        }
        return keys;
    }

    private List<FormField> findExplicitLeafKeys(FormClass formSchema) {
        List<FormField> fields = new ArrayList<>();
        for (FormField formField : formSchema.getFields()) {
            if(formField.isKey() && !(formField.getType() instanceof ReferenceType)) {
                fields.add(formField);
            }
        }
        return fields;
    }


    private boolean hasExplicitKeys(FormClass formClass) {
        for (FormField formField : formClass.getFields()) {
            if(formField.isKey()) {
                return true;
            }
        }
        return false;
    }


    private List<LookupKey> findImplicitKeys(FormClass formSchema) {

        Optional<FormField> textField = firstFieldOfType(formSchema, TextType.TYPE_CLASS);
        if(textField.isPresent()) {
            return Collections.singletonList(new LookupKey(formSchema.getLabel(), formSchema, textField.get()));
        } else {
            // Otherwise we have to use the autogenerated id :-(
            return Collections.singletonList(new LookupKey(formSchema, Collections.<LookupKey>emptyList()));
        }
    }

    private Optional<FormField> firstFieldOfType(FormClass formClass, FieldTypeClass typeClass) {
        for (FormField formField : formClass.getFields()) {
            if(formField.getType().getTypeClass().equals(typeClass)) {
                return Optional.of(formField);
            }
        }
        return Optional.absent();
    }

    public Maybe<String> label(RecordTree tree, RecordRef ref) {
        if(keys.size() == 1) {
            Maybe<FormInstance> record = tree.getRecord(ref);
            return record.transform(new Function<FormInstance, String>() {
                @Override
                public String apply(FormInstance record) {
                    return keys.get(0).label(record);
                }
            });
        } else {
            return Maybe.of("TODO");
        }
    }


    public List<LookupKey> getKeys() {
        return keys;
    }

    public LookupKey getKey(int i) {
        return keys.get(i);
    }
}

