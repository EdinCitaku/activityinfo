import com.google.appengine.task.RunTask
import org.activityinfo.store.mysql.MySqlDatabase


ext {
    configFile = project.file("$buildDir/config.properties")
}

// Generate the server's configuration on-the-fly based on this build's properties
def writeConfiguration(MySqlDatabase database) {
    Properties config = new Properties()
    config.setProperty("hibernate.connection.pool_size", "0")
    config.setProperty("hibernate.connection.driver_class", "com.mysql.jdbc.Driver")
    config.setProperty("hibernate.connection.username", database.server.username)
    config.setProperty("hibernate.connection.password", database.server.password)
    config.setProperty("hibernate.connection.url", database.url)
    
    // Point to the postmark stub service
    config.setProperty("postmark.url", "http://localhost:${postmarkStubPort}/email")
    config.setProperty("postmark.key", "POSTMARK_API_TEST")

    configFile.withOutputStream { OutputStream out ->
        config.store(out, "Acceptance Test Configuration")
    }
}

def healthCheck() {
    // Verify that the server actually started
    try {
        URL url = new URL("http://localhost:${devServerPort}/login")
        def connection = url.openConnection() as HttpURLConnection

        println("DevServer started successfully: ${connection.responseCode}")

    } catch(IOException e) {
        throw new RuntimeException("AppEngine DevServer failed to start: ${e.message}", e)
    }
}

task appengineExplodeDevMode(type: Copy) {
    group = "Google App Engine"
    description = "Creates a partial, exploded web app layout for GWT Dev Mode"
    
    // In order to run (super)dev mode, we need ONLY the part of the
    // web app required for the server side, which includes
    // compiled Java classes, resources, and server-side libraries
    
    dependsOn compileJava
    from("$projectDir/src/main/webapp")
    from(configurations.runtime) {
        into "WEB-INF/lib"
    }
    from(sourceSets.main.output) {
        into "WEB-INF/classes"
    }
    into "$buildDir/explodedDevMode"
}


task appengineDevMode(type: JavaExec) {
    dependsOn appengineDownloadSdk
    dependsOn appengineExplodeDevMode

    main = 'com.google.gwt.dev.DevMode'
    
    // Java sources first, so that changes get picked up on refresh
    classpath sourceSets.main.java.srcDirs
    classpath sourceSets.main.resources.srcDirs
    classpath project(":i18n").sourceSets.main.java.srcDirs
    classpath project(":i18n").sourceSets.main.resources.srcDirs
    classpath project(":store:offline").sourceSets.main.java.srcDirs
    classpath project(":store:offline").sourceSets.main.resources.srcDirs

    // Compiled java classes and libraries second
    classpath sourceSets.main.runtimeClasspath
    classpath configurations.gwt
    classpath configurations.gwtSdk
    

    args '-server', 'com.google.appengine.tools.development.gwt.AppEngineLauncher'
    args '-war', "${buildDir}/explodedDevMode"
    args '-startupUrl', 'login'
    args '-port', devServerPort
    args 'org.activityinfo.ui.ActivityInfoFFTest'

    doFirst {
        // The SDK root is only available after appengineDownloadSdk runs
        def sdkRoot = System.getProperty('appengine.sdk.root')
        classpath "${sdkRoot}/lib/appengine-tools-api.jar"
        jvmArgs "-javaagent:${sdkRoot}/lib/agent/appengine-agent.jar"
        
        // Write the application configuration pointing to the development database
        writeConfiguration mysql.localDev
        jvmArgs "-Dactivityinfo.config=${configFile}"
        jvmArgs "-Xdebug"
        jvmArgs "-Xrunjdwp:transport=dt_socket,server=y,suspend=n,address=8000"
    }
}


task appengineDevMode3(type: JavaExec) {
    dependsOn appengineDownloadSdk
    dependsOn appengineExplodeDevMode

    main = 'com.google.gwt.dev.DevMode'

    // Java sources first, so that changes get picked up on refresh
    classpath sourceSets.main.java.srcDirs
    classpath sourceSets.main.resources.srcDirs
    for(subProject in [':i18n', ':ui:app', ':ui:style', ':ui:icons']) {
        classpath project(subProject).sourceSets.main.java.srcDirs
        classpath project(subProject).sourceSets.main.resources.srcDirs
    }
    classpath project(':ui:style').task('grunt_build').outputs.files
    
    // Compiled java classes and libraries second
    classpath configurations.gwt
    classpath configurations.gwtSdk

    args '-server', 'com.google.appengine.tools.development.gwt.AppEngineLauncher'
    args '-war', "${buildDir}/explodedDevMode"
    args '-startupUrl', 'app'
    args '-port', devServerPort
    args 'org.activityinfo.ui.App'

    doFirst {
        // The SDK root is only available after appengineDownloadSdk runs
        def sdkRoot = System.getProperty('appengine.sdk.root')
        classpath "${sdkRoot}/lib/appengine-tools-api.jar"
        classpath project(':ui:app').configurations.getByName('gwt').files
        classpath project(':ui:style').configurations.getByName('gwt').files

        jvmArgs "-javaagent:${sdkRoot}/lib/agent/appengine-agent.jar"

        // Write the application configuration pointing to the development database
        writeConfiguration mysql.localDev
        jvmArgs "-Dactivityinfo.config=${configFile}"
        jvmArgs "-Xdebug"
        jvmArgs "-Xrunjdwp:transport=dt_socket,server=y,suspend=n,address=8000"
    }
}

appengineRun {
    ext.database = mysql.localDev
    
    // Bind to all address so that we can test ODK from the local network
    // For example, http://192.168.1.1
    httpAddress = "0.0.0.0"
}

task appengineStartAT(type: RunTask) {
    group = "Google App Engine"
    description = "Starts a local AppEngine Development Server for Acceptance Testing in the background"

    dependsOn 'appengineExplodeApp', 'setupDatabaseAT'

    daemon = true
    ext.database = mysql.localAT
}

task appengineRunAT(type: RunTask) {
    group = "Google App Engine"
    description = "Runs a local AppEngine Development Server for Acceptance Testing"

    dependsOn 'appengineExplodeApp', 'setupDatabaseAT', 'classes', 'compileGwt'
    ext.database = mysql.localAT
}

task appengineStartInstrumentedAT(type: RunTask) {
    group = "Google App Engine"
    description = "Starts a local AppEngine Dev Server instrumented for measuring test coverage"

    dependsOn 'classes', 'compileGwt'
    dependsOn 'setupDatabaseAT'
    dependsOn 'appengineExplodeInstrumentedApp'

    daemon = true
    explodedAppDirectory = appengineExplodeInstrumentedApp.warDir
    ext.database = mysql.localAT

    doFirst {
        def jacocoAgent = project.zipTree(configurations.jacocoAgent.singleFile)
        def jacocoAgentJar = jacocoAgent.filter { it.name == 'jacocoagent.jar' }.singleFile.absolutePath

        logger.info("Starting DevServer with jacoco agent path: ${jacocoAgentJar}.")

        jvmFlags.add("-javaagent:${jacocoAgentJar}=destfile=${jacocoAcceptanceDataFile}")
        
        // Apparently between the Jacoco instrumentation adds significantly more pressure on
        // the Permgen space. Set a high maximum to avoid the case that the dev server crashes
        // during the tests
        jvmFlags.add("-XX:MaxPermSize=2048m")
    }
}

tasks.withType(RunTask) {

    // Provide a configuration for the server
    jvmFlags = ["-Dactivityinfo.config=${configFile}"]

    doFirst {
        writeConfiguration ext.database
    }
    
    doLast {
        if(daemon) {
            // Make sure the server successfully started
            healthCheck()    
        }
    }
}